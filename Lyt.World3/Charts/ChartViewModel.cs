namespace Lyt.World3.Charts;

using LiveChartsCore.SkiaSharpView;

public sealed partial class ChartViewModel : ViewModel<ChartView>
{
    #region Colouring 

    // Viz Palette : https://projects.susielu.com/viz-palette 
    // https://www.simplifiedsciencepublishing.com/resources/best-color-palettes-for-scientific-figures-and-data-visualizations

    // Colors generated by https://colorbrewer2.org/
    //
    // ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf'] 
    // dark red, medium blue, medium green, Violet, Orange, Yellow, Medium Brown, Pink 

    // Pastel colors (alpha,r,g,b)
    private static readonly SKColor pastelLightGreen = new(0xffa3F2cd);
    private static readonly SKColor pastelSalmon = new(0xfffdc0a0);
    private static readonly SKColor pastelLightPink = new(0xfffFAaB4);
    private static readonly SKColor pastelLightBlue = new(0xffA6B5FF);
    private static readonly SKColor pastelLightYellow = new(0xfffff2Be);
    private static readonly SKColor pastelLightBrown = new(0xfff1e2cc);
    private static readonly SKColor pastelLightGray = new(0xffcccccc);
    private static readonly SKColor pastelLightTeal = new(0xffcbd5e8);

    private static readonly SKColor[] pastelColors =
        [
            pastelLightGreen, pastelSalmon, pastelLightPink,
            pastelLightYellow, pastelLightBlue, pastelLightBrown,
            pastelLightGray, pastelLightTeal,
        ];

    private static SKColor Color(int i) => pastelColors[i % pastelColors.Length];

    #region Wes Anderson Palettes 

    // See: https://github.com/karthik/wesanderson 

    /*
  BottleRocket1 = c("#A42820", "#5F5647", "#9B110E", "#3F5151", "#4E2A1E", "#550307", "#0C1707"),
  BottleRocket2 = c("#FAD510", "#CB2314", "#273046", "#354823", "#1E1E1E"),
  Rushmore1 = c("#E1BD6D", "#EABE94", "#0B775E", "#35274A", "#F2300F"),
  Rushmore = c("#E1BD6D", "#EABE94", "#0B775E", "#35274A", "#F2300F"),
  Royal1 = c("#899DA4", "#C93312", "#FAEFD1", "#DC863B"),
  Royal2 = c("#9A8822", "#F5CDB4", "#F8AFA8", "#FDDDA0", "#74A089"),
  Zissou1 = c("#3B9AB2", "#78B7C5", "#EBCC2A", "#E1AF00", "#F21A00"),
  Zissou1Continuous = c("#3A9AB2", "#6FB2C1", "#91BAB6", "#A5C2A3", "#BDC881", "#DCCB4E", "#E3B710", "#E79805", "#EC7A05", "#EF5703", "#F11B00"),
  Darjeeling1 = c("#FF0000", "#00A08A", "#F2AD00", "#F98400", "#5BBCD6"),
  Darjeeling2 = c("#ECCBAE", "#046C9A", "#D69C4E", "#ABDDDE", "#000000"),
  Chevalier1 = c("#446455", "#FDD262", "#D3DDDC", "#C7B19C"),
  FantasticFox1 = c("#DD8D29", "#E2D200", "#46ACC8", "#E58601", "#B40F20"),
  Moonrise1 = c("#F3DF6C", "#CEAB07", "#D5D5D3", "#24281A"),
  Moonrise2 = c("#798E87", "#C27D38", "#CCC591", "#29211F"),
  Moonrise3 = c("#85D4E3", "#F4B5BD", "#9C964A", "#CDC08C", "#FAD77B"),
  Cavalcanti1 = c("#D8B70A", "#02401B", "#A2A475", "#81A88D", "#972D15"),
  GrandBudapest1 = c("#F1BB7B", "#FD6467", "#5B1A18", "#D67236"),
  GrandBudapest2 = c("#E6A0C4", "#C6CDF7", "#D8A499", "#7294D4"),
  IsleofDogs1 = c("#9986A5", "#79402E", "#CCBA72", "#0F0D0E", "#D9D0D3", "#8D8680"),
  IsleofDogs2 = c("#EAD3BF", "#AA9486", "#B6854D", "#39312F", "#1C1718"),
  FrenchDispatch = c("#90D4CC", "#BD3027", "#B0AFA2", "#7FC0C6", "#9D9C85"),
  AsteroidCity1 = c("#0A9F9D", "#CEB175", "#E54E21", "#6C8645", "#C18748"),
  AsteroidCity2 = c("#C52E19", "#AC9765", "#54D8B1", "#b67c3b", "#175149", "#AF4E24"),
  AsteroidCity3 = c("#FBA72A", "#D3D4D8", "#CB7A5C", "#5785C1")

    */
    #endregion Wes Anderson Palettes

    private static readonly SKColor s_gray = new(195, 195, 195);
    private static readonly SKColor s_gray1 = new(160, 160, 160);
    private static readonly SKColor s_gray2 = new(90, 90, 90);
    private static readonly SKColor s_dark = new(10, 10, 40, 220);
    private static readonly SKColor s_dark3 = new(60, 60, 60, 128);

    private static readonly SKColor s_lightBlue = new(205, 210, 255, 50);

    #endregion Colouring 

    private readonly PlotDefinition plotDefinition;
    private readonly bool isMini;
    private readonly int curveCount;

    private WorldModel? model;
    private bool isPointerDown;
    private Func<double, string>? xAxisLabeler;

    [ObservableProperty]
    public LiveChartsCore.Measure.Margin drawMargin;

    [ObservableProperty]
    public ISeries[] series;

    [ObservableProperty]
    public ISeries[] scrollbarSeries;

    [ObservableProperty]
    public string title;

    [ObservableProperty]
    public double titleFontSize;

    [ObservableProperty]
    public DrawMarginFrame frame;

    [ObservableProperty]
    public Axis[]? scrollableAxes;

    [ObservableProperty]
    public RectangularSection[]? thumbs;

    [ObservableProperty]
    public ICartesianAxis[]? yAxes;

    [ObservableProperty]
    public Axis[]? invisibleX;

    [ObservableProperty]
    public Axis[]? invisibleY;

    public ChartViewModel(PlotDefinition plotDefinition, bool isMini = false)
    {
        this.plotDefinition = plotDefinition;
        this.curveCount = plotDefinition.Curves.Count;
        this.isMini = isMini;

        this.Series = [];
        this.ScrollbarSeries = [];
        this.Title = string.Empty;
        this.Frame = new();
        this.DrawMargin = new();
    }

    public PlotDefinition PlotDefinition => this.plotDefinition;

    public void DataBind(WorldModel model)
    {
        this.model = model;

        if (this.ViewBase is null)
        {
            throw new Exception("No view: Failed to startup?");
        }

        if (this.model is null) // || ?? 
        {
            throw new Exception("Null or Invalid model");
        }

        // Step #1: Generate data for X axis (years)
        int length = (int)((this.model.Time - this.model.InitialTime()) / this.model.DeltaTime);
        double[] dataX = new double[length];
        for (int i = 0; i < length; ++i)
        {
            double xi = this.model.InitialTime() + i * this.model.DeltaTime;
            dataX[i] = xi;
        }

        // Step #2: Extract data from the model to create collections of Observable points
        var pointsList = new List<List<ObservablePoint>>(curveCount);
        for (int i = 0; i < curveCount; ++i)
        {
            var curve = plotDefinition.Curves[i];
            double[] dataY = [.. this.model.GetData(curve.EquationName)];
            var points = new List<ObservablePoint>(length);
            for (int k = 0; k < length; ++k)
            {
                double xk = dataX[k];
                double yk = dataY[k];
                if (curve.UseIntegers)
                {
                    yk = Math.Round(yk);
                }

                yk *= curve.ScaleFactor;
                points.Add(new ObservablePoint(xk, yk));
            }

            pointsList.Add(points);
        }

        // Step #3: Create Plot Title (regular text block) 
        this.Title = this.plotDefinition.Title;
        this.TitleFontSize = this.isMini ? 18.0 : 28.0;

        // Step #4: Create Series 
        var series = new List<LineSeries<ObservablePoint>>();
        for (int i = 0; i < curveCount; ++i)
        {
            var curve = plotDefinition.Curves[i];
            var points = pointsList[i];
            var color = Color(i);
            int scaleAt = curve.ScaleUsingAxisIndex;
            var serie = CreateSerie(points, curve.Name, color, scaleAt);
            serie.LineSmoothness = curve.LineSmoothness;
            series.Add(serie);
        }

        this.Series = [.. series];
        this.ScrollbarSeries = [series[0]];

        // Step #5: Create X Axis and scrolling stuff 
        var xAxis = CreateAxis("Year", s_gray);
        this.xAxisLabeler = xAxis.Labeler;
        xAxis.NamePadding = new LiveChartsCore.Drawing.Padding(4);
        xAxis.Padding = new LiveChartsCore.Drawing.Padding(4);
        if (this.isMini)
        {
            xAxis.IsVisible = false;
        }

        this.ScrollableAxes = [xAxis];
        this.InvisibleX = [new Axis() { IsVisible = false }];
        this.InvisibleY = [new Axis() { IsVisible = false }];
        this.Thumbs = [new RectangularSection { Fill = new SolidColorPaint(s_lightBlue) }];

        // Step #6: Create Y Axes - Mini view has none
        var axes = new List<Axis>();
        for (int i = 0; i < curveCount; ++i)
        {
            var curve = plotDefinition.Curves[i];
            if (curve.HasAxis)
            {
                var color = Color(i);
                var axis = CreateAxis(curve.Name, color);
                if (curve.UseIntegers)
                {
                    axis.Labeler = this.IntegerLabeler;
                }

                if (this.isMini)
                {
                    axis.IsVisible = false;
                }

                axes.Add(axis);
            }
        }

        this.YAxes = [.. axes];

        // Step #7 a : Customize legend ( No legend on mini view ) 
        CartesianChart? cartesianChart = null;
        if (this.isMini)
        {
            if (this.ViewBase is MiniChartView view)
            {
                // Still needed for making it visible a bit below 
                cartesianChart = view.Chart;
            }
        }
        else
        {
            if (this.ViewBase is ChartView view)
            {
                cartesianChart = view.Chart;
            }
        }

        if (cartesianChart is null)
        {
            throw new ArgumentException("No Chart");
        }

        if (!this.isMini)
        {
            cartesianChart.LegendBackgroundPaint = new SolidColorPaint(s_dark);
            cartesianChart.LegendTextPaint = new SolidColorPaint(s_gray);
            cartesianChart.LegendTextSize = 13;
        }

        // Step #7 b : Customize tooltip
        cartesianChart.TooltipBackgroundPaint = new SolidColorPaint(s_dark);
        cartesianChart.TooltipTextPaint = new SolidColorPaint(s_gray);
        cartesianChart.TooltipTextSize = 12;

        // Step #8 : Adjust margins 
        // force the left margin and the right margin to be the same in both charts, this will
        // align the start and end point of the "draw margin", no matter the size of
        // the labels in the Y axis of both chart.
        int axesCount = isMini ? 0 : axes.Count;
        float auto = LiveChartsCore.Measure.Margin.Auto;
        float left = 90.0f * axesCount + 20.0f;
        this.DrawMargin = new(left, auto, 50, auto);

        Schedule.OnUiThread(
            50,
            () =>
            {
                cartesianChart.IsVisible = true;
            }, DispatcherPriority.Background);
    }

    [RelayCommand]
    public void ChartUpdated(ChartCommandArgs args)
    {
        // Debug.WriteLine("Chart updated");
        if (this.isMini)
        {
            return;
        }

        if (this.Thumbs is null || this.Thumbs.Length == 0)
        {
            Debug.WriteLine("no thumbs");
            return;
        }

        var cartesianChart = (ICartesianChartView)args.Chart;
        var firstXAxis = cartesianChart.XAxes.FirstOrDefault();
        if (firstXAxis is null)
        {
            Debug.WriteLine("no first axis");
            return;
        }

        // update the scroll bar thumb when the chart is updated (zoom/pan)
        // this will let the user know the current visible range
        RectangularSection thumb = this.Thumbs[0];
        thumb.Xi = firstXAxis.MinLimit;
        thumb.Xj = firstXAxis.MaxLimit;

        if (this.ScrollableAxes is null || this.ScrollableAxes.Length == 0)
        {
            Debug.WriteLine("No ScrollableAxes");
            return;
        }
        var xAxis = this.ScrollableAxes[0];
        if (thumb.Xj - thumb.Xi > 20)
        {
            if (this.xAxisLabeler is not null)
            {
                xAxis.Labeler = this.xAxisLabeler;
            }
        }
        else
        {
            xAxis.Labeler = this.IntegerLabeler;
        }
    }

    [RelayCommand]
    public void PointerDown(PointerCommandArgs args) => this.isPointerDown = true;

    [RelayCommand]
    public void PointerUp(PointerCommandArgs args) => this.isPointerDown = false;

    [RelayCommand]
    public void PointerMove(PointerCommandArgs args)
    {
        if (this.isMini)
        {
            return;
        }

        if (!this.isPointerDown)
        {
            return;
        }

        // if (Debugger.IsAttached) { Debugger.Break(); } 

        if (this.Thumbs is null || this.Thumbs.Length == 0)
        {
            Debug.WriteLine("No thumbs");
            return;
        }

        if (this.ScrollableAxes is null || this.ScrollableAxes.Length == 0)
        {
            Debug.WriteLine("No ScrollableAxes");
            return;
        }

        var xAxis = this.ScrollableAxes[0];
        var chartView = (ICartesianChartView)args.Chart;
        var positionInData = chartView.ScalePixelsToData(args.PointerPosition);
        var thumb = this.Thumbs[0];
        double? currentRange = thumb.Xj - thumb.Xi;
        if (!currentRange.HasValue)
        {
            Debug.WriteLine("No value for currentRange");
            return;
        }

        // update the scroll bar thumb when the user is dragging the chart
        double? xi = positionInData.X - currentRange / 2;
        double? xj = positionInData.X + currentRange / 2;

        // Debug.WriteLine("Position: " + thumb.Xi.ToString() + "  " + thumb.Xj.ToString());
        if (xj - xi > 20)
        {
            if (this.xAxisLabeler is not null)
            {
                xAxis.Labeler = this.xAxisLabeler;
            }
        }
        else
        {
            xAxis.Labeler = this.IntegerLabeler;
        }

        if (xj - xi <= 3)
        {
            return;
        }

        // update the chart visible range
        if (xi >= 1900)
        {
            thumb.Xi = xi;
            this.ScrollableAxes[0].MinLimit = xi;
        }

        if (xj <= 2120)
        {
            thumb.Xj = xj;
            this.ScrollableAxes[0].MaxLimit = xj;
        }
    }

    private static LineSeries<ObservablePoint> CreateSerie(
        IReadOnlyCollection<ObservablePoint> points, string name, SKColor color, int scaleAt)
        => new()
        {
            Values = points,
            Name = name,
            LineSmoothness = 0.7,
            // "fat' lines: 2 pixels 
            Stroke = new SolidColorPaint(color, 2.0f),
            Fill = null,
            GeometrySize = 0,
            // it will be scaled at the Axis[scaleAt] instance 
            ScalesYAt = scaleAt,
        };

    private static Axis CreateAxis(string name, SKColor color)
        => new()
        {
            Name = name,
            // Value changes the axis width: See Step #8 above 
            NameTextSize = 14,
            TextSize = 14,
            NamePadding = new LiveChartsCore.Drawing.Padding(0, 12),
            Padding = new LiveChartsCore.Drawing.Padding(0, 0, 20, 0),
            // MUST create a new Paint object for each property or else rendering gets messed up
            NamePaint = new SolidColorPaint(color),
            LabelsPaint = new SolidColorPaint(color),
            TicksPaint = new SolidColorPaint(color),
            SubticksPaint = new SolidColorPaint(color),
            DrawTicksPath = true,
            ShowSeparatorLines = false,
        };

    private string IntegerLabeler(double value)
    {
        int intValue = (int)(value + 0.5);
        if (Math.Abs(intValue - value) > 0.001)
        {
            return string.Empty;
        }

        return intValue.ToString("D");
    }
}
